"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/session.ts":
/*!************************!*\
  !*** ./lib/session.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sessionManager: function() { return /* binding */ sessionManager; },\n/* harmony export */   useSessionPersistence: function() { return /* binding */ useSessionPersistence; }\n/* harmony export */ });\n// Gestionnaire de session pour persist dans la session courante uniquement\n// Se renouvelle à chaque fermeture/actualisation de page\nclass SessionManager {\n    static getInstance() {\n        if (!SessionManager.instance) {\n            SessionManager.instance = new SessionManager();\n        }\n        return SessionManager.instance;\n    }\n    generateSessionId() {\n        // Format: timestamp + random string\n        const timestamp = Date.now();\n        const randomPart = Math.random().toString(36).substring(2, 15);\n        return \"session_\".concat(timestamp, \"_\").concat(randomPart);\n    }\n    initializeSession() {\n        // Toujours créer une nouvelle session (ne pas récupérer l'ancienne)\n        const sessionData = {\n            sessionId: this.sessionId,\n            createdAt: new Date(),\n            messages: [],\n            analysisResults: null\n        };\n        this.saveToSessionStorage(sessionData);\n        console.log(\"\\uD83C\\uDD94 Nouvelle session cr\\xe9\\xe9e: \".concat(this.sessionId));\n    }\n    getSessionId() {\n        return this.sessionId;\n    }\n    saveMessages(messages) {\n        const sessionData = this.getSessionData();\n        if (sessionData) {\n            sessionData.messages = messages;\n            this.saveToSessionStorage(sessionData);\n        }\n    }\n    getMessages() {\n        const sessionData = this.getSessionData();\n        return (sessionData === null || sessionData === void 0 ? void 0 : sessionData.messages) || [];\n    }\n    saveAnalysisResults(results) {\n        const sessionData = this.getSessionData();\n        if (sessionData) {\n            sessionData.analysisResults = results;\n            this.saveToSessionStorage(sessionData);\n        }\n    }\n    getAnalysisResults() {\n        const sessionData = this.getSessionData();\n        return (sessionData === null || sessionData === void 0 ? void 0 : sessionData.analysisResults) || null;\n    }\n    clearSession() {\n        sessionStorage.removeItem(this.storageKey);\n        this.initializeSession();\n    }\n    getSessionData() {\n        try {\n            const stored = sessionStorage.getItem(this.storageKey);\n            if (stored) {\n                const parsed = JSON.parse(stored);\n                // Reconstituer les dates\n                parsed.createdAt = new Date(parsed.createdAt);\n                return parsed;\n            }\n        } catch (error) {\n            console.error(\"Erreur lors de la lecture de la session:\", error);\n        }\n        return null;\n    }\n    saveToSessionStorage(data) {\n        try {\n            sessionStorage.setItem(this.storageKey, JSON.stringify(data));\n        } catch (error) {\n            console.error(\"Erreur lors de la sauvegarde de la session:\", error);\n        }\n    }\n    getSessionInfo() {\n        var _data_messages;\n        const data = this.getSessionData();\n        return {\n            sessionId: this.sessionId,\n            createdAt: (data === null || data === void 0 ? void 0 : data.createdAt) || new Date(),\n            messageCount: (data === null || data === void 0 ? void 0 : (_data_messages = data.messages) === null || _data_messages === void 0 ? void 0 : _data_messages.length) || 0\n        };\n    }\n    constructor(){\n        this.storageKey = \"reddit-analysis-session\";\n        // Générer un nouvel ID de session à chaque instanciation (= chaque actualisation/ouverture)\n        this.sessionId = this.generateSessionId();\n        this.initializeSession();\n    }\n}\n// Export de l'instance singleton\nconst sessionManager = SessionManager.getInstance();\n// Utilitaires pour React\nconst useSessionPersistence = ()=>{\n    return {\n        sessionId: sessionManager.getSessionId(),\n        saveMessages: sessionManager.saveMessages.bind(sessionManager),\n        getMessages: sessionManager.getMessages.bind(sessionManager),\n        saveAnalysisResults: sessionManager.saveAnalysisResults.bind(sessionManager),\n        getAnalysisResults: sessionManager.getAnalysisResults.bind(sessionManager),\n        clearSession: sessionManager.clearSession.bind(sessionManager),\n        getSessionInfo: sessionManager.getSessionInfo.bind(sessionManager)\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SVY7WUFDbENxQyxjQUFjSixDQUFBQSxpQkFBQUEsNEJBQUFBLGlCQUFBQSxLQUFNdEIsUUFBUSxjQUFkc0IscUNBQUFBLGVBQWdCSyxNQUFNLEtBQUk7UUFDMUM7SUFDRjtJQWxHQSxhQUFzQjthQUZkWixhQUFhO1FBR25CLDRGQUE0RjtRQUM1RixJQUFJLENBQUNqQixTQUFTLEdBQUcsSUFBSSxDQUFDWCxpQkFBaUI7UUFDdkMsSUFBSSxDQUFDUyxpQkFBaUI7SUFDeEI7QUErRkY7QUFFQSxpQ0FBaUM7QUFDMUIsTUFBTWdDLGlCQUFpQjVDLGVBQWVDLFdBQVcsR0FBRTtBQUUxRCx5QkFBeUI7QUFDbEIsTUFBTTRDLHdCQUF3QjtJQUNuQyxPQUFPO1FBQ0wvQixXQUFXOEIsZUFBZXZCLFlBQVk7UUFDdENDLGNBQWNzQixlQUFldEIsWUFBWSxDQUFDd0IsSUFBSSxDQUFDRjtRQUMvQ3BCLGFBQWFvQixlQUFlcEIsV0FBVyxDQUFDc0IsSUFBSSxDQUFDRjtRQUM3Q25CLHFCQUFxQm1CLGVBQWVuQixtQkFBbUIsQ0FBQ3FCLElBQUksQ0FBQ0Y7UUFDN0RqQixvQkFBb0JpQixlQUFlakIsa0JBQWtCLENBQUNtQixJQUFJLENBQUNGO1FBQzNEaEIsY0FBY2dCLGVBQWVoQixZQUFZLENBQUNrQixJQUFJLENBQUNGO1FBQy9DSCxnQkFBZ0JHLGVBQWVILGNBQWMsQ0FBQ0ssSUFBSSxDQUFDRjtJQUNyRDtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3Nlc3Npb24udHM/MWRlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZXN0aW9ubmFpcmUgZGUgc2Vzc2lvbiBwb3VyIHBlcnNpc3QgZGFucyBsYSBzZXNzaW9uIGNvdXJhbnRlIHVuaXF1ZW1lbnRcclxuLy8gU2UgcmVub3V2ZWxsZSDDoCBjaGFxdWUgZmVybWV0dXJlL2FjdHVhbGlzYXRpb24gZGUgcGFnZVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uRGF0YSB7XHJcbiAgc2Vzc2lvbklkOiBzdHJpbmdcclxuICBjcmVhdGVkQXQ6IERhdGVcclxuICBtZXNzYWdlczogYW55W11cclxuICBhbmFseXNpc1Jlc3VsdHM6IGFueVxyXG59XHJcblxyXG5jbGFzcyBTZXNzaW9uTWFuYWdlciB7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFNlc3Npb25NYW5hZ2VyXHJcbiAgcHJpdmF0ZSBzZXNzaW9uSWQ6IHN0cmluZ1xyXG4gIHByaXZhdGUgc3RvcmFnZUtleSA9ICdyZWRkaXQtYW5hbHlzaXMtc2Vzc2lvbidcclxuXHJcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vIEfDqW7DqXJlciB1biBub3V2ZWwgSUQgZGUgc2Vzc2lvbiDDoCBjaGFxdWUgaW5zdGFuY2lhdGlvbiAoPSBjaGFxdWUgYWN0dWFsaXNhdGlvbi9vdXZlcnR1cmUpXHJcbiAgICB0aGlzLnNlc3Npb25JZCA9IHRoaXMuZ2VuZXJhdGVTZXNzaW9uSWQoKVxyXG4gICAgdGhpcy5pbml0aWFsaXplU2Vzc2lvbigpXHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IFNlc3Npb25NYW5hZ2VyIHtcclxuICAgIGlmICghU2Vzc2lvbk1hbmFnZXIuaW5zdGFuY2UpIHtcclxuICAgICAgU2Vzc2lvbk1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgU2Vzc2lvbk1hbmFnZXIoKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFNlc3Npb25NYW5hZ2VyLmluc3RhbmNlXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdlbmVyYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XHJcbiAgICAvLyBGb3JtYXQ6IHRpbWVzdGFtcCArIHJhbmRvbSBzdHJpbmdcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KClcclxuICAgIGNvbnN0IHJhbmRvbVBhcnQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpXHJcbiAgICByZXR1cm4gYHNlc3Npb25fJHt0aW1lc3RhbXB9XyR7cmFuZG9tUGFydH1gXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRpYWxpemVTZXNzaW9uKCk6IHZvaWQge1xyXG4gICAgLy8gVG91am91cnMgY3LDqWVyIHVuZSBub3V2ZWxsZSBzZXNzaW9uIChuZSBwYXMgcsOpY3Vww6lyZXIgbCdhbmNpZW5uZSlcclxuICAgIGNvbnN0IHNlc3Npb25EYXRhOiBTZXNzaW9uRGF0YSA9IHtcclxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcclxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICBtZXNzYWdlczogW10sXHJcbiAgICAgIGFuYWx5c2lzUmVzdWx0czogbnVsbFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnNhdmVUb1Nlc3Npb25TdG9yYWdlKHNlc3Npb25EYXRhKVxyXG4gICAgY29uc29sZS5sb2coYPCfhpQgTm91dmVsbGUgc2Vzc2lvbiBjcsOpw6llOiAke3RoaXMuc2Vzc2lvbklkfWApXHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0U2Vzc2lvbklkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uSWRcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzYXZlTWVzc2FnZXMobWVzc2FnZXM6IGFueVtdKTogdm9pZCB7XHJcbiAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHRoaXMuZ2V0U2Vzc2lvbkRhdGEoKVxyXG4gICAgaWYgKHNlc3Npb25EYXRhKSB7XHJcbiAgICAgIHNlc3Npb25EYXRhLm1lc3NhZ2VzID0gbWVzc2FnZXNcclxuICAgICAgdGhpcy5zYXZlVG9TZXNzaW9uU3RvcmFnZShzZXNzaW9uRGF0YSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRNZXNzYWdlcygpOiBhbnlbXSB7XHJcbiAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHRoaXMuZ2V0U2Vzc2lvbkRhdGEoKVxyXG4gICAgcmV0dXJuIHNlc3Npb25EYXRhPy5tZXNzYWdlcyB8fCBbXVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHNhdmVBbmFseXNpc1Jlc3VsdHMocmVzdWx0czogYW55KTogdm9pZCB7XHJcbiAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHRoaXMuZ2V0U2Vzc2lvbkRhdGEoKVxyXG4gICAgaWYgKHNlc3Npb25EYXRhKSB7XHJcbiAgICAgIHNlc3Npb25EYXRhLmFuYWx5c2lzUmVzdWx0cyA9IHJlc3VsdHNcclxuICAgICAgdGhpcy5zYXZlVG9TZXNzaW9uU3RvcmFnZShzZXNzaW9uRGF0YSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRBbmFseXNpc1Jlc3VsdHMoKTogYW55IHtcclxuICAgIGNvbnN0IHNlc3Npb25EYXRhID0gdGhpcy5nZXRTZXNzaW9uRGF0YSgpXHJcbiAgICByZXR1cm4gc2Vzc2lvbkRhdGE/LmFuYWx5c2lzUmVzdWx0cyB8fCBudWxsXHJcbiAgfVxyXG5cclxuICBwdWJsaWMgY2xlYXJTZXNzaW9uKCk6IHZvaWQge1xyXG4gICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpXHJcbiAgICB0aGlzLmluaXRpYWxpemVTZXNzaW9uKClcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0U2Vzc2lvbkRhdGEoKTogU2Vzc2lvbkRhdGEgfCBudWxsIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JlZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KVxyXG4gICAgICBpZiAoc3RvcmVkKSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzdG9yZWQpXHJcbiAgICAgICAgLy8gUmVjb25zdGl0dWVyIGxlcyBkYXRlc1xyXG4gICAgICAgIHBhcnNlZC5jcmVhdGVkQXQgPSBuZXcgRGF0ZShwYXJzZWQuY3JlYXRlZEF0KVxyXG4gICAgICAgIHJldHVybiBwYXJzZWRcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyZXVyIGxvcnMgZGUgbGEgbGVjdHVyZSBkZSBsYSBzZXNzaW9uOicsIGVycm9yKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2F2ZVRvU2Vzc2lvblN0b3JhZ2UoZGF0YTogU2Vzc2lvbkRhdGEpOiB2b2lkIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0VycmV1ciBsb3JzIGRlIGxhIHNhdXZlZ2FyZGUgZGUgbGEgc2Vzc2lvbjonLCBlcnJvcilcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRTZXNzaW9uSW5mbygpOiB7IHNlc3Npb25JZDogc3RyaW5nOyBjcmVhdGVkQXQ6IERhdGU7IG1lc3NhZ2VDb3VudDogbnVtYmVyIH0ge1xyXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0U2Vzc2lvbkRhdGEoKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcclxuICAgICAgY3JlYXRlZEF0OiBkYXRhPy5jcmVhdGVkQXQgfHwgbmV3IERhdGUoKSxcclxuICAgICAgbWVzc2FnZUNvdW50OiBkYXRhPy5tZXNzYWdlcz8ubGVuZ3RoIHx8IDBcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBkZSBsJ2luc3RhbmNlIHNpbmdsZXRvblxyXG5leHBvcnQgY29uc3Qgc2Vzc2lvbk1hbmFnZXIgPSBTZXNzaW9uTWFuYWdlci5nZXRJbnN0YW5jZSgpXHJcblxyXG4vLyBVdGlsaXRhaXJlcyBwb3VyIFJlYWN0XHJcbmV4cG9ydCBjb25zdCB1c2VTZXNzaW9uUGVyc2lzdGVuY2UgPSAoKSA9PiB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHNlc3Npb25JZDogc2Vzc2lvbk1hbmFnZXIuZ2V0U2Vzc2lvbklkKCksXHJcbiAgICBzYXZlTWVzc2FnZXM6IHNlc3Npb25NYW5hZ2VyLnNhdmVNZXNzYWdlcy5iaW5kKHNlc3Npb25NYW5hZ2VyKSxcclxuICAgIGdldE1lc3NhZ2VzOiBzZXNzaW9uTWFuYWdlci5nZXRNZXNzYWdlcy5iaW5kKHNlc3Npb25NYW5hZ2VyKSxcclxuICAgIHNhdmVBbmFseXNpc1Jlc3VsdHM6IHNlc3Npb25NYW5hZ2VyLnNhdmVBbmFseXNpc1Jlc3VsdHMuYmluZChzZXNzaW9uTWFuYWdlciksXHJcbiAgICBnZXRBbmFseXNpc1Jlc3VsdHM6IHNlc3Npb25NYW5hZ2VyLmdldEFuYWx5c2lzUmVzdWx0cy5iaW5kKHNlc3Npb25NYW5hZ2VyKSxcclxuICAgIGNsZWFyU2Vzc2lvbjogc2Vzc2lvbk1hbmFnZXIuY2xlYXJTZXNzaW9uLmJpbmQoc2Vzc2lvbk1hbmFnZXIpLFxyXG4gICAgZ2V0U2Vzc2lvbkluZm86IHNlc3Npb25NYW5hZ2VyLmdldFNlc3Npb25JbmZvLmJpbmQoc2Vzc2lvbk1hbmFnZXIpXHJcbiAgfVxyXG59ICJdLCJuYW1lcyI6WyJTZXNzaW9uTWFuYWdlciIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJnZW5lcmF0ZVNlc3Npb25JZCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJyYW5kb21QYXJ0IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiaW5pdGlhbGl6ZVNlc3Npb24iLCJzZXNzaW9uRGF0YSIsInNlc3Npb25JZCIsImNyZWF0ZWRBdCIsIm1lc3NhZ2VzIiwiYW5hbHlzaXNSZXN1bHRzIiwic2F2ZVRvU2Vzc2lvblN0b3JhZ2UiLCJjb25zb2xlIiwibG9nIiwiZ2V0U2Vzc2lvbklkIiwic2F2ZU1lc3NhZ2VzIiwiZ2V0U2Vzc2lvbkRhdGEiLCJnZXRNZXNzYWdlcyIsInNhdmVBbmFseXNpc1Jlc3VsdHMiLCJyZXN1bHRzIiwiZ2V0QW5hbHlzaXNSZXN1bHRzIiwiY2xlYXJTZXNzaW9uIiwic2Vzc2lvblN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwic3RvcmFnZUtleSIsInN0b3JlZCIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImRhdGEiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2V0U2Vzc2lvbkluZm8iLCJtZXNzYWdlQ291bnQiLCJsZW5ndGgiLCJzZXNzaW9uTWFuYWdlciIsInVzZVNlc3Npb25QZXJzaXN0ZW5jZSIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/session.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/store.ts":
/*!**********************!*\
  !*** ./lib/store.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAnalysisStore: function() { return /* binding */ useAnalysisStore; },\n/* harmony export */   useChatStore: function() { return /* binding */ useChatStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./session */ \"(app-pages-browser)/./lib/session.ts\");\n\n\nconst useChatStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        messages: [],\n        isTyping: false,\n        sessionId: _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.getSessionId(),\n        addMessage: (message)=>{\n            const newMessage = {\n                ...message,\n                id: Date.now().toString(),\n                timestamp: new Date()\n            };\n            set((state)=>{\n                const updatedMessages = [\n                    ...state.messages,\n                    newMessage\n                ];\n                // Sauvegarder dans sessionStorage\n                _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.saveMessages(updatedMessages);\n                return {\n                    messages: updatedMessages\n                };\n            });\n        },\n        setTyping: (isTyping)=>set({\n                isTyping\n            }),\n        clearMessages: ()=>{\n            set({\n                messages: []\n            });\n            // Effacer aussi de sessionStorage\n            _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.saveMessages([]);\n        },\n        setSessionId: (sessionId)=>set({\n                sessionId\n            }),\n        initializeFromSession: ()=>{\n            // Charger les messages depuis sessionStorage au démarrage\n            const savedMessages = _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.getMessages();\n            if (savedMessages.length > 0) {\n                // Reconstituer les dates des messages\n                const messagesWithDates = savedMessages.map((msg)=>({\n                        ...msg,\n                        timestamp: new Date(msg.timestamp)\n                    }));\n                set({\n                    messages: messagesWithDates,\n                    sessionId: _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.getSessionId()\n                });\n            } else {\n                set({\n                    sessionId: _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.getSessionId()\n                });\n            }\n        }\n    }));\nconst useAnalysisStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        state: {\n            subreddit: \"\",\n            isAnalyzing: false,\n            analysisResults: null,\n            recommendations: null\n        },\n        setSubreddit: (subreddit)=>set((state)=>({\n                    state: {\n                        ...state.state,\n                        subreddit\n                    }\n                })),\n        setAnalyzing: (isAnalyzing)=>set((state)=>({\n                    state: {\n                        ...state.state,\n                        isAnalyzing\n                    }\n                })),\n        setAnalysisResults: (analysisResults)=>{\n            set((state)=>({\n                    state: {\n                        ...state.state,\n                        analysisResults\n                    }\n                }));\n            // Sauvegarder dans sessionStorage\n            _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.saveAnalysisResults(analysisResults);\n        },\n        setRecommendations: (recommendations)=>set((state)=>({\n                    state: {\n                        ...state.state,\n                        recommendations\n                    }\n                })),\n        reset: ()=>{\n            set({\n                state: {\n                    subreddit: \"\",\n                    isAnalyzing: false,\n                    analysisResults: null,\n                    recommendations: null\n                }\n            });\n            // Effacer de sessionStorage\n            _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.saveAnalysisResults(null);\n        },\n        initializeFromSession: ()=>{\n            // Charger les résultats d'analyse depuis sessionStorage\n            const savedResults = _session__WEBPACK_IMPORTED_MODULE_0__.sessionManager.getAnalysisResults();\n            if (savedResults) {\n                set((state)=>({\n                        state: {\n                            ...state.state,\n                            analysisResults: savedResults\n                        }\n                    }));\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSUQsY0FBYztnQkFDaEJ0QyxJQUFJLENBQUNjLFFBQVc7d0JBQ2RBLE9BQU87NEJBQUUsR0FBR0EsTUFBTUEsS0FBSzs0QkFBRWdCLGlCQUFpQlE7d0JBQWE7b0JBQ3pEO1lBQ0Y7UUFDRjtJQUNGLElBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N0b3JlLnRzP2U4NDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCdcclxuaW1wb3J0IHsgc2Vzc2lvbk1hbmFnZXIgfSBmcm9tICcuL3Nlc3Npb24nXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2Uge1xyXG4gIGlkOiBzdHJpbmdcclxuICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50J1xyXG4gIGNvbnRlbnQ6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogRGF0ZVxyXG4gIGlzTG9hZGluZz86IGJvb2xlYW5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBbmFseXNpc1N0YXRlIHtcclxuICBzdWJyZWRkaXQ6IHN0cmluZ1xyXG4gIGlzQW5hbHl6aW5nOiBib29sZWFuXHJcbiAgYW5hbHlzaXNSZXN1bHRzOiBhbnlcclxuICByZWNvbW1lbmRhdGlvbnM6IGFueVxyXG59XHJcblxyXG5pbnRlcmZhY2UgQ2hhdFN0b3JlIHtcclxuICBtZXNzYWdlczogTWVzc2FnZVtdXHJcbiAgaXNUeXBpbmc6IGJvb2xlYW5cclxuICBzZXNzaW9uSWQ6IHN0cmluZ1xyXG4gIGFkZE1lc3NhZ2U6IChtZXNzYWdlOiBPbWl0PE1lc3NhZ2UsICdpZCcgfCAndGltZXN0YW1wJz4pID0+IHZvaWRcclxuICBzZXRUeXBpbmc6IChpc1R5cGluZzogYm9vbGVhbikgPT4gdm9pZFxyXG4gIGNsZWFyTWVzc2FnZXM6ICgpID0+IHZvaWRcclxuICBzZXRTZXNzaW9uSWQ6IChzZXNzaW9uSWQ6IHN0cmluZykgPT4gdm9pZFxyXG4gIGluaXRpYWxpemVGcm9tU2Vzc2lvbjogKCkgPT4gdm9pZFxyXG59XHJcblxyXG5pbnRlcmZhY2UgQW5hbHlzaXNTdG9yZSB7XHJcbiAgc3RhdGU6IEFuYWx5c2lzU3RhdGVcclxuICBzZXRTdWJyZWRkaXQ6IChzdWJyZWRkaXQ6IHN0cmluZykgPT4gdm9pZFxyXG4gIHNldEFuYWx5emluZzogKGlzQW5hbHl6aW5nOiBib29sZWFuKSA9PiB2b2lkXHJcbiAgc2V0QW5hbHlzaXNSZXN1bHRzOiAocmVzdWx0czogYW55KSA9PiB2b2lkXHJcbiAgc2V0UmVjb21tZW5kYXRpb25zOiAocmVjb21tZW5kYXRpb25zOiBhbnkpID0+IHZvaWRcclxuICByZXNldDogKCkgPT4gdm9pZFxyXG4gIGluaXRpYWxpemVGcm9tU2Vzc2lvbjogKCkgPT4gdm9pZFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQ2hhdFN0b3JlID0gY3JlYXRlPENoYXRTdG9yZT4oKHNldCwgZ2V0KSA9PiAoe1xyXG4gIG1lc3NhZ2VzOiBbXSxcclxuICBpc1R5cGluZzogZmFsc2UsXHJcbiAgc2Vzc2lvbklkOiBzZXNzaW9uTWFuYWdlci5nZXRTZXNzaW9uSWQoKSwgLy8gVXRpbGlzZXIgbCdJRCBkZSBzZXNzaW9uIGfDqW7DqXLDqVxyXG4gIFxyXG4gIGFkZE1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XHJcbiAgICBjb25zdCBuZXdNZXNzYWdlID0ge1xyXG4gICAgICAuLi5tZXNzYWdlLFxyXG4gICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNldCgoc3RhdGUpID0+IHtcclxuICAgICAgY29uc3QgdXBkYXRlZE1lc3NhZ2VzID0gWy4uLnN0YXRlLm1lc3NhZ2VzLCBuZXdNZXNzYWdlXVxyXG4gICAgICAvLyBTYXV2ZWdhcmRlciBkYW5zIHNlc3Npb25TdG9yYWdlXHJcbiAgICAgIHNlc3Npb25NYW5hZ2VyLnNhdmVNZXNzYWdlcyh1cGRhdGVkTWVzc2FnZXMpXHJcbiAgICAgIHJldHVybiB7IG1lc3NhZ2VzOiB1cGRhdGVkTWVzc2FnZXMgfVxyXG4gICAgfSlcclxuICB9LFxyXG4gIFxyXG4gIHNldFR5cGluZzogKGlzVHlwaW5nKSA9PiBzZXQoeyBpc1R5cGluZyB9KSxcclxuICBcclxuICBjbGVhck1lc3NhZ2VzOiAoKSA9PiB7XHJcbiAgICBzZXQoeyBtZXNzYWdlczogW10gfSlcclxuICAgIC8vIEVmZmFjZXIgYXVzc2kgZGUgc2Vzc2lvblN0b3JhZ2VcclxuICAgIHNlc3Npb25NYW5hZ2VyLnNhdmVNZXNzYWdlcyhbXSlcclxuICB9LFxyXG4gIFxyXG4gIHNldFNlc3Npb25JZDogKHNlc3Npb25JZCkgPT4gc2V0KHsgc2Vzc2lvbklkIH0pLFxyXG4gIFxyXG4gIGluaXRpYWxpemVGcm9tU2Vzc2lvbjogKCkgPT4ge1xyXG4gICAgLy8gQ2hhcmdlciBsZXMgbWVzc2FnZXMgZGVwdWlzIHNlc3Npb25TdG9yYWdlIGF1IGTDqW1hcnJhZ2VcclxuICAgIGNvbnN0IHNhdmVkTWVzc2FnZXMgPSBzZXNzaW9uTWFuYWdlci5nZXRNZXNzYWdlcygpXHJcbiAgICBpZiAoc2F2ZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIFJlY29uc3RpdHVlciBsZXMgZGF0ZXMgZGVzIG1lc3NhZ2VzXHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VzV2l0aERhdGVzID0gc2F2ZWRNZXNzYWdlcy5tYXAobXNnID0+ICh7XHJcbiAgICAgICAgLi4ubXNnLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUobXNnLnRpbWVzdGFtcClcclxuICAgICAgfSkpXHJcbiAgICAgIHNldCh7IFxyXG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1dpdGhEYXRlcyxcclxuICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25NYW5hZ2VyLmdldFNlc3Npb25JZCgpXHJcbiAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXQoeyBzZXNzaW9uSWQ6IHNlc3Npb25NYW5hZ2VyLmdldFNlc3Npb25JZCgpIH0pXHJcbiAgICB9XHJcbiAgfVxyXG59KSlcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VBbmFseXNpc1N0b3JlID0gY3JlYXRlPEFuYWx5c2lzU3RvcmU+KChzZXQsIGdldCkgPT4gKHtcclxuICBzdGF0ZToge1xyXG4gICAgc3VicmVkZGl0OiAnJyxcclxuICAgIGlzQW5hbHl6aW5nOiBmYWxzZSxcclxuICAgIGFuYWx5c2lzUmVzdWx0czogbnVsbCxcclxuICAgIHJlY29tbWVuZGF0aW9uczogbnVsbCxcclxuICB9LFxyXG4gIFxyXG4gIHNldFN1YnJlZGRpdDogKHN1YnJlZGRpdCkgPT5cclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIHN0YXRlOiB7IC4uLnN0YXRlLnN0YXRlLCBzdWJyZWRkaXQgfSxcclxuICAgIH0pKSxcclxuICAgICBcclxuICBzZXRBbmFseXppbmc6IChpc0FuYWx5emluZykgPT5cclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIHN0YXRlOiB7IC4uLnN0YXRlLnN0YXRlLCBpc0FuYWx5emluZyB9LFxyXG4gICAgfSkpLFxyXG4gICAgIFxyXG4gIHNldEFuYWx5c2lzUmVzdWx0czogKGFuYWx5c2lzUmVzdWx0cykgPT4ge1xyXG4gICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgc3RhdGU6IHsgLi4uc3RhdGUuc3RhdGUsIGFuYWx5c2lzUmVzdWx0cyB9LFxyXG4gICAgfSkpXHJcbiAgICAvLyBTYXV2ZWdhcmRlciBkYW5zIHNlc3Npb25TdG9yYWdlXHJcbiAgICBzZXNzaW9uTWFuYWdlci5zYXZlQW5hbHlzaXNSZXN1bHRzKGFuYWx5c2lzUmVzdWx0cylcclxuICB9LFxyXG4gIFxyXG4gIHNldFJlY29tbWVuZGF0aW9uczogKHJlY29tbWVuZGF0aW9ucykgPT5cclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIHN0YXRlOiB7IC4uLnN0YXRlLnN0YXRlLCByZWNvbW1lbmRhdGlvbnMgfSxcclxuICAgIH0pKSxcclxuICAgICBcclxuICByZXNldDogKCkgPT4ge1xyXG4gICAgc2V0KHtcclxuICAgICAgc3RhdGU6IHtcclxuICAgICAgICBzdWJyZWRkaXQ6ICcnLFxyXG4gICAgICAgIGlzQW5hbHl6aW5nOiBmYWxzZSxcclxuICAgICAgICBhbmFseXNpc1Jlc3VsdHM6IG51bGwsXHJcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBudWxsLFxyXG4gICAgICB9LFxyXG4gICAgfSlcclxuICAgIC8vIEVmZmFjZXIgZGUgc2Vzc2lvblN0b3JhZ2VcclxuICAgIHNlc3Npb25NYW5hZ2VyLnNhdmVBbmFseXNpc1Jlc3VsdHMobnVsbClcclxuICB9LFxyXG4gIFxyXG4gIGluaXRpYWxpemVGcm9tU2Vzc2lvbjogKCkgPT4ge1xyXG4gICAgLy8gQ2hhcmdlciBsZXMgcsOpc3VsdGF0cyBkJ2FuYWx5c2UgZGVwdWlzIHNlc3Npb25TdG9yYWdlXHJcbiAgICBjb25zdCBzYXZlZFJlc3VsdHMgPSBzZXNzaW9uTWFuYWdlci5nZXRBbmFseXNpc1Jlc3VsdHMoKVxyXG4gICAgaWYgKHNhdmVkUmVzdWx0cykge1xyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIHN0YXRlOiB7IC4uLnN0YXRlLnN0YXRlLCBhbmFseXNpc1Jlc3VsdHM6IHNhdmVkUmVzdWx0cyB9XHJcbiAgICAgIH0pKVxyXG4gICAgfVxyXG4gIH1cclxufSkpIl0sIm5hbWVzIjpbImNyZWF0ZSIsInNlc3Npb25NYW5hZ2VyIiwidXNlQ2hhdFN0b3JlIiwic2V0IiwiZ2V0IiwibWVzc2FnZXMiLCJpc1R5cGluZyIsInNlc3Npb25JZCIsImdldFNlc3Npb25JZCIsImFkZE1lc3NhZ2UiLCJtZXNzYWdlIiwibmV3TWVzc2FnZSIsImlkIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwidGltZXN0YW1wIiwic3RhdGUiLCJ1cGRhdGVkTWVzc2FnZXMiLCJzYXZlTWVzc2FnZXMiLCJzZXRUeXBpbmciLCJjbGVhck1lc3NhZ2VzIiwic2V0U2Vzc2lvbklkIiwiaW5pdGlhbGl6ZUZyb21TZXNzaW9uIiwic2F2ZWRNZXNzYWdlcyIsImdldE1lc3NhZ2VzIiwibGVuZ3RoIiwibWVzc2FnZXNXaXRoRGF0ZXMiLCJtYXAiLCJtc2ciLCJ1c2VBbmFseXNpc1N0b3JlIiwic3VicmVkZGl0IiwiaXNBbmFseXppbmciLCJhbmFseXNpc1Jlc3VsdHMiLCJyZWNvbW1lbmRhdGlvbnMiLCJzZXRTdWJyZWRkaXQiLCJzZXRBbmFseXppbmciLCJzZXRBbmFseXNpc1Jlc3VsdHMiLCJzYXZlQW5hbHlzaXNSZXN1bHRzIiwic2V0UmVjb21tZW5kYXRpb25zIiwicmVzZXQiLCJzYXZlZFJlc3VsdHMiLCJnZXRBbmFseXNpc1Jlc3VsdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/store.ts\n"));

/***/ })

});